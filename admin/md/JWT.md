# JWT(JSON WEB TOKEN)

---

> 왜 사용되고 어디에 쓰이는가


## SESSION

웹브라우저 -> 주소요청 -> 서버는 해당 주소에 맞는 컨트롤러 메서드를 찾음 -> html 파일 리턴(이 때 http 헤더를 달아 줌)
- header
    - 쿠키 : 세션ID
    - 최초 요청시 만들어 저장하고 두 번째 요청부터는 만들어진 세션 아이디를 달아서 요청 보냄
    - 이 전에 요청이 왔던 친구구나
    - 서버는 카드를 만들어 줄 때마다 목록을 만들어 둠
    - 세션은 서버가 강제로 없애거나 사용자가 브라우저를 종료 시키면 사라지거나 종료 됨
- session
  - 단점 
    - 로그인 요청 시 인증을 위해 많이 사용 됨 
      - 클라이언트 최초 리퀘스트 -> 서버는 session 이라는 저장소에 session 아이디를 하나 만듦 -> 응답 해줄 때 헤더에 session id 돌려 줌   
        -> 클라이언트 웹 브라우저에 session id가 저장 됨 -> 사용자 로그인 요청 -> DB 유저 정보 저장 -> 메인 페이지 리턴  
        -> 로그인 한 사람 구분
      - 클라이언트가 요청할 때 서버에서 어떤 정보를 응답
      - 클라이언트가 100만명? 너무 많음 동접자 수가 평균적으로 1000명
      - 서버가 동접자 100명만 처리 할 수 있는 경우 나머지 900명은 기다려야 함
      - 동접자수가 많은 대형 사이트들은 서버를 10개 정도 만들어 둠
      - 이 상태에서 로드밸런싱 처리, 부하 분산
      - 로드밸런싱 처리가 된 경우 클라이언트가 동일한 서버에 요청을 보낸다는 보장이 안 됨
    - 해결 방법 
      - 스티킹 서버 ? 처음 요청한 서버에 계속 붙어 있게 하는 것
      - 세션 복제하는 방법도 있음
      - 서버들이 한 군데 데이터베이스에 값을 넣어놓고 session 값을 공유해서 사용
        - 단점 : 세션이라는 건 서버가 들고 잇는 메모리에 접근을 해서 데이터를 가져오는 것 그래서 빠름, 하지만 세션값이 데이터베이스가 있다 생각하면 I/O가 일어남, 하드디스크에서 찾는 동작을 하며 아주 많이 느려짐
        - CPU는 데이터가 필요할 때 램으로 감 -> 만약 램에 데이터가 없으면 하드디스크에서 찾음 -> 찾은 데이터를 램에 저장 -> 그 이후 요청부터 램에 데이터가 있는 경우 하드디스크에 접근하지 않고 램에서 찾음
        - 하드디스크에서 계속 찾게 하는 것은 좋지 않음 
      - 메모리 공유 서버 사용
        - 메모리만 사용하면 I/O가 일어나지 않음
        - 모든 서버들이 메모리 서버에 접근
        - 메모리 서버는 램만 있음 하드 없음
        - 대표적으로 Redis 서버가 있음

## TCP
- 신뢰성 있는 통신
- 내가 보낸 데이터가 잘 갔는지 안 갔는지를 항상 확인
- 아이디, 비밀번호 정확하게 오지 않으면 인증이 안됨, 이런 정보는 UDP로 할 수 없음
- 웹은 TCP 통신!

## UDP
- ack 신경쓰지 않고 보내고 싶은 데이터를 무작위로 보냄
- 신뢰성 없는 통신
- 속도 빠름, 중요하지 않은 데이터 전송
- 전화 : 통화 할 때 통신이 좋지 않아 안녕 반..ㅇ 이렇게 전달이 되어도 상대방이 추측 가능
- 동영상 : 24프레임 중 1,2 프레임이 유실 되어도 사람은 추측 할 수 있음


## 통신 : osi7계층을 거쳐 전송 
  - 응용계층 : 롤 프로그램 / 궁 
  - 프리젠테이션계층 : 암호화 / 압축
  - 세션계층 : 인증 체크(상대방 컴퓨터가 켜져 있는지, 거기에 접근 할 수 있는지 등을 체크)
  - 트랜스포트계층  : TCP 통신을 할 지 UDP 통신을 할지 선택
  - 네트워크계층 : IP 찾음
  - 데이터링크계층 : IP로 집을 찾아 감, 이 집에 공유기가 하나 있고 공유기에 컴퓨터가 네 개가 있을 때 집 내부망 LAN(근거리 통신, 로컬 통신) 내에서 알맞는 곳을 찾아가 줌
  - 물리계층 : 실제 정비선(광케이블) -> 물리계층부터 다시 데이터 전달해서 응용프로그램까지 전달
- 이메일을 보낼 때 이 과정을 쭉 거쳐 보내지게 됨


## 보안(CIA)
- 문서 전달 시 기밀성(다른 나라에서 가져감), 무결성(문서 변경), 가용성(문서 위조) 깨짐
- 문서를 받는 곳에서 풀 수 있는 열쇠가 없어 이 열쇠를 보내줄 수 밖에 없음. 이 상황에 열쇠를 탈취당할 수 있다.
- 가용성
  - 최고의 전사들을 같이 보낸다. 문서를 지킨다
  - 암호화 시 A열쇠로 잠금. A열쇠로만 풀 수 있음 -> 기밀성 유지
- 기밀성
  - 암호화
  - 문서를 탈취 당할 수 있어도 문서 자체는 기밀성 유지
- 무결성
  - A라는 열쇠로만 열 수 있게 해놨는데 금고가 1KG밖에 되지 않아 가져갈 수 있으므로 벽에 딱 붙여둔다.

## 보안 이슈 해결
1. 열쇠 전달 문제
2. 데이터가 누구로 부터 왔는지(인증)

> 이 두 문제를 어떻게 해결할 수 있을까?

## RSA(암호화)
- 두가지 키를 가지고 있음
- public key : 공개키
- private key : 개인키
- 공개키 기반 암호화
  - A가 B의 공개키로 사랑해 암호화 -> B가 받음(B도 공개키, 개인키를 가지고 있음)
    - A는 A의 개인키만, B는 B의 개인키만 가지고 있음
    - A가 B의 공개키를 가질 수 있는 이유 -> B가 공개적으로 키를 올려 둠
    - B가 받아서 자신의 개인키로 열어 봄 
    - 암호화로 사용되는 것은 공개키로 잠금
  - A가 A의 개인키로 'C에게 송금했다'는 내용 암호화 -> C가 탈취 후 내용 확인 상관없음 -> 후에 B가 확인
    - C가 열어봐도 상관 없는 이유는 내용이 중요한 것이 아닌 A가 보낸 데이터라는 사실이 중요 한 것
    - B가 문서를 받았을 때 이 것은 A가 보낸 데이터구나 라는 것을 알 수 있음
    - A의 공개키로 열어볼 수 있는 문서는 A의 개인키로 암호화 한 문서이기 때문
    - 전자문서에서 서명으로 사용
    - 인증 방식으로 사용되는 것은 개인키로 잠금
- 공개키로 잠그면 개인키로 열어볼 수 있고 개인키로 잠그면 공개키로 열어볼 수 있다.
- 인증문제 해결 가능


- 시멘트릭키(대칭키)
- 키 하나로 잠그고 여는 걸 같이 하는 것 


## RFC
- http: 벨 연구소 -> www 
- 벨 연구소 내부망 컴퓨터끼리 통신하려면 선으로 연결해서 데이터 송수신
- A 대학 똑같이 내부망 구성 후 자기들끼리 통신
  - 벨 연구소와 A 대학이 통신하고 싶다면?
    - 약속된 규칙이 필요
- 약속된 문서 하나가 RFC 1번 문서
- 이 약속된 문서방식을 프로토콜이라 함
- B 대학도 통신을 원함
  - 또 다른 규칙이 생김 RFC 2문서
- 이렇게 네트워크들이 연결 됨
- 연결되면서 2, 3, 4, 5 ~~~ 쭉 문서들이 생김
- 점점 약속이 많아짐
- 네트워크들이 계속 모여서 만들어 진 것이 월드 와이드 웹(www) 인터넷 이라고 함
- 인터넷이라는 것은 RFC 문서로 만들어져 있음
- 이 약속의 프로토콜이 http 프로토콜


- 현재 비대해져 있는 네트워크 망
- 규칙을 적용해달라고 요청해야 RFC 문서가 만들어 짐 
- 내 규칙을 네트워크 망 전부가 동의를 해주어야 함
- 좋은 규칙이어야 동의 해주겠지?
- 지금 만들어지는 RFC 문서는 동등한 관계로 만들어지는 문서는 아님(현재 너무 크기 때문)

**JSON WEB TOKEN은 RFC 7519에 만들어진 약속**

## JSON 웹 토큰
- 당사자간에 정보를 JSON 객체로 안전하게 전송하기 위한 컴팩트하고 독립적인 방식을 정의 하는 개방형 표준(RFC 7519)
- JWT는 비밀(HMAC 알고리즘) 또는 RSA 또는 ECDSA를 사용하는 공개 / 개인 키 쌍을 사용하여 서명 가능
- JWT를 암호화하여 당사자간에 비밀을 제공 할 수도 있찌만 서명 된 토큰에 중점을 둘 것(내가 쓴것이 맞다)

### JWT 구조
- Header
  - 토큰 유형과 사용중인 서명 알고리즘 두 부분으로 구성
  - Base64Url로 인코딩
- Payload
  - 클레임
    - 등록 된 클레임
      - 발행자, 만료시간, 주제, 청중
    - 개인 클레임
      - 사용에 동의하고 등록 또는 공개 클레임이 아닌 당사자간에 정보를 공유하기 위해 생성 된 사용자 지정 클레임 
      - 유저 아이디 같은 것들을 넣음
  - 페이로드 Base64Url로 인코딩 되어 JSON 웹 토큰의 두 번째 부분 형성
- Signature
  - header, payload, 나만알고 있는 비밀 키를 HMAC SHA256 알고리즘으로 암호화
- `xxxxx.yyyyy.zzzzz`

## JWT 적용
- 로그인 하면 서버가 세션이 아닌 제이슨 웹 토큰을 만들어 줄 것임
- 서버가 헤더를 만들고 페이로드를 만들고 시그니처를 만듦
  - 헤더
    - HS256 서명
  - 페이로드
    - { username : ssar }
  - 시그니처
    - HS256(header + payload + 서버만 알고 있는 키 값) 암호화
      - HS256 : HMAC이라는 방식으로 SHA256 암호화 -> 해시(복호화 할 수 없는 키) 암호
      - HMAC : 시크릿 키를 포함한 암호화 방식
- 각각 Base64로 인코딩 -> 클라이언트에게 돌려 줌
- 로그인 시도 후 인증이 완료 되면 jwt만듦
- 토큰을 만들어 돌려주면 이상한 난수처럼 보임
- 클라이언트가 들고 있음
  - 어디에 들고 있으면 좋을까?
    - 클라이언트 웹 브라우저에 로컬스토리지 영역 같은 곳에 넣어 둠
- 클라이언트가 다시 요청(내 정보 줘) -> 로컬 스토리지에 저장한 jwt와 함께 요청 
- 서버가 jwt을 받음, 받아서 이 토큰이 신뢰 할 수 있는 토큰인지 검증 해야 함
- 어떻게 검증?
- 시그니처에 HS256으로 암호화 된 정보
- 헤더, 페이로드 자기가 알고 잇는 시크릿 키를 가지고 똑같이 HS256으로 암호화 해 봄
- 값이 같으면 인증이 된 것 
- 그 후 payload에 담겨있는 username으로 DB에서 정보를 가져와 응답 해 주면 됨


## Access Token & Refresh Token
---

### Access / Refresh Token 재발급 원리
1. 로그인 과정 시 Access Token과 Refresh Token을 모두 발급
   - 이때, Refresh Token만 서버측의 DB에 저장하고 Refresh Token과 Access Token을 쿠키 혹은 웹스토리지에 저장
2. 사용자가 인증이 필요한 API에 접근하고자 하면, 가장 먼저 토큰을 검사
   1. access token과 refresh token 모두가 만료된 경우
      - 에러 발생(재 로그인하여 둘 다 새로 발급)
   2. access token은 만료됐지만, refresh token은 유효한 경우
      - refresh token을 검증하여 access token 재발급
      - 클라이언트(쿠키, 웹스토리지)에 저장되어있는 refresh token과 서버 DB에 저장되어 있는 refresh token이 일치한지 확인 후 access token 재발급
   3. access token은 유효하지만, refresh token은 만료된 경우
      - access token을 검증하여 refresh token 재발급
      - access token이 유효하다는 것은 이미 인증된 것이니 바로 refresh token 재발급
   4. access token과 refresh token 모두가 유효한 경우
      - 정상 처리
3. 로그아웃을 하면 Access Token과 Refresh Token을 모두 만료시킨다.


### Refresh Token 인증 과정
1. 사용자가 ID, PW를 통해 로그인
2. 서버에서는 회원 DB에서 값을 비교
3. 로그인이 완료되면 Access Token, Refresh Token을 발급
4. 서버는 Redis에 Refresh Token 저장
5. 사용자는 Refresh Token은 안전한 저장소에 저장 후, Access Token을 헤더에 실어 요청을 보냄
6. Access Token을 검증
7. 데이터 전송
8. 시간이 지나 Access Token 만료
9. 사용자는 이전과 동일하게 Access Token을 헤더에 실어 요청을 보냄
10. 서버는 Access Token이 만료됨을 확인하고 권한 없음을 신호로 보냄
11. 사용자는 Refresh Token과 Access Token을 함께 서버로 보낸다.
12. 서버는 받은 Access Token이 조작되지 않았는지 확인한 후, Refresh Token과 사용자의 DB에 저장되어 있던 Refresh Token을 비교한다. Token이 동일하고 유효기간도 지나지 않았다면 새로운 Access Token을 발급해준다.
13. 서버는 새로운 Access Token을 헤더에 실어 다시 API 요청 응답을 진행한다.


> Access Token 만료가 될 때마다 9~10 과정을 거칠 필요는 없다.  
> 사용자(프론트엔드) 에서 Access Token의 Payload를 통해 유효기간을 알 수 있다.  
> 따라서 프론트엔드 단에서 API 요청 전에 토큰이 만료됐다면 곧바로 재발급 요청을 할 수도 있다.